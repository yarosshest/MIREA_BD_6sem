\graphicspath{{img}} % path to graphics
\section*{\LARGE Выполнение практической работы}
\addcontentsline{toc}{section}{Выполнение практической работы}

\section*{\LARGE Выполнение практической работы}
\addcontentsline{toc}{section}{Выполнение практической работы}

\section{Агрегация}

Операции агрегации обрабатывают записи в базе данных и возвращают
результаты выполненной операции. Операции агрегации группируют значения
из множества документов, после чего могут производить некоторые операции
над сгруппированными данными для получения. В SQL count(*) вместе с group
by эквивалентно агрегации в MongoDB.

Например, у нас есть следующие объекты:
\begin{image}
	\includegrph{img}
	\caption{Объекты}
	\label{fig:object}
\end{image}

Теперь для этой коллекции найдем, сколько руководств (tutorial) написал
каждый из пользователей. Ниже указана команда с использованием aggregate
для решения задачи и полученный результат.
\begin{image}
	\includegrph{img_1}
	\caption{Агрегация}
	\label{fig:aggregate}
\end{image}


\section{Репликация}

Репликация --- это процесс синхронизации данных между несколькими
серверами. Репликация обеспечивает избыточность и повышает доступность
данных благодаря наличию нескольких копий данных на разных серверах баз
данных. Репликация защищает базу данных при потери какого-либо сервера.\par
В MongoDB репликация достигается с помощью группы реплик (replica
set). Группа реплик --- это группа экземпляров, которые содержат один и тот же
набор данных. В группе один узел является основным узлом, на который
приходят все операции записи. Все другие экземпляры повторяют операции,
которые произвел основной, чтобы у них был тот же набор данных. В группе
реплик может быть только один основной узел. Если основной узел перестает
отвечать, происходят перевыборы основного узла. После восстановления
сломанного узла он возвращается в группу, но уже в роле дополнительного
узла.

Особенности набора реплик

\begin{itemize}
	\item Кластер из N узлов;
	\item Любой узел может быть основным;
	\item Все операции записи идут на основной узел;
	\item Автоматическое переключение при сбое;
	\item Автоматическое восстановление;
	\item Выборы первичного узла.
\end{itemize}

Пример образа docker-compose с несколькими репликами

\begin{lstlisting}[language=bash]
version: "3.8"
services:
  mongo1:
    image: mongo:latest
    container_name: mongo1
    command: ["--replSet", "my-replica-set", "--bind_ip_all"
		, "--port", "30001"]
    volumes:
      - ./data/mongo-1:/data/db
    ports:
      - 30001:30001
    healthcheck:
      test: test \$\$(echo "rs.initiate({_id:'my-replica-set',members:[{_id:0,host:\\"mongo1:30001\\"},{_id:1,host:\\"mongo2:30002\\"},{_id:2 ,host:\\"mongo3:30003\\"}]}, {force:true}).ok || rs.status().ok" | mongosh --port 30001 --quiet) -eq 1
      interval: 10s
      start_period: 30s

  mongo2:
    image: mongo:latest
    container_name: mongo2
    command: ["--replSet", "my-replica-set", "--bind_ip_all"
		, "--port", "30002"]
    volumes:
      - ./data/mongo-2:/data/db
    ports:
      - 30002:30002
    depends_on:
      - mongo1

  mongo3:
    image: mongo:latest
    container_name: mongo3
    command: ["--replSet", "my-replica-set", "--bind_ip_all"
		, "--port", "30003"]
    volumes:
      - ./data/mongo-3:/data/db
    ports:
      - 30003:30003
    depends_on:
      - mongo2
\end{lstlisting}

\texttt{depends\_on}: позволяет точно определять PRIMARY узел при первом
запуске. Иначе им может стать один из одновременно запущенных узлов.\par
Healthcheck необходим для проверки состояния узлов каждые n секунд.\par
Команда, прописанная через echo это конфигурация кластера mongodb и
ее применение в одном флаконе.\par
Подключимся к первому узлу при помощи команды.

\begin{lstlisting}[language=bash]
docker exec -it mongo1 sh -c "mongo --port 30001"
\end{lstlisting}

\begin{image}
	\includegrph{img_2}
	\caption{Подключение к первому узлу}
	\label{fig:connect:mongo1}
\end{image}

Вставим любой кусочек информации, например:

\begin{lstlisting}[language=bash]
db.first.insert({ title: 'cat'});
\end{lstlisting}

Отключим первый узел и подключимся ко второму.
Сделаем запрос на получение информации из коллекции:

\begin{image}
	\includegrph{img_3}
	\caption{Подключение ко второму узлу}
	\label{fig:connect:mongo2}
\end{image}

Как можно заметить, информация при выключении узла не была потеряна
и узел номер 2 стал PRIMARY, заменяя первый узел.

Включим узел номер 1 обратно.
После подключения можно заметить, что перебалансировки не
произошло и PRIMARY до сих пор является узел номер 2:

\begin{image}
	\includegrph{img_4}
	\caption{Подключение к первому узлу}
	\label{fig:connect:mongo1:2}
\end{image}

\section{Sharding}

Сегментирование (Sharding) --- это процесс хранения записей данных на
нескольких машинах. В MongoDB данный подход также присутствует для того,
чтобы обеспечить работу при росте данных. Поскольку размер данных
увеличивается, одной машины может быть недостаточно для хранения данных
или обеспечения приемлемой скорости чтения и
записи. Шардинг/сегментирование решает эту проблему. С его помощью для
поддержки роста данных и требований операций чтения и записи необходимо
добавить дополнительные машины.\par
Почему же стоит использовать шардинг:

\begin{itemize}
	\item При репликации все записи идут на главный узел, его мощности
	может не хватать;
	\item Один набор реплик имеет ограничение в 12 узлов;
	\item Памяти может не хватать, если объем запрашиваемых данных
	достаточно большой;
	\item Вертикальное масштабирование чаще всего дороже горизонтального.
\end{itemize}

При сегментации используются 3 основных компонента:\par
Шарды/сегменты. Они используются для хранения данных. Они
обеспечивают высокую доступность и согласованность данных. В рабочих
системах, каждый шард --- это отдельная группа реплик.\par
Сервера конфигурации. Они хранят метаданные кластера. Эти данные
содержат данные о том, на каком сегменте хранится каждый набор данных.
Маршрутизатор запросов использует эти метаданные для отправки операций на
определенные сегменты. В рабочих системах кластеры имеют ровно 3 сервера
конфигурации.\par
Маршрутизаторы запросов (Query Routers) --- это, в основном,
экземпляры MongoDB, взаимодействующие с клиентскими приложениями и
направляющие операции в соответствующий сегмент. Маршрутизатор запросов
обрабатывает и направляет операции на сегменты, а затем возвращает
результаты клиентам. Кластер может содержать более одного маршрутизатора
запросов для разделения нагрузки клиентских запросов. Клиент отправляет
запросы одному маршрутизатору запросов. Как правило, у кластера с
сегментами присутствует множество маршрутизаторов запросов.

\section{Отношения в MongoDB}

Отношения в MongoDB могут быть представлены с помощью двух
вариантов: вложенного документа и ссылки. Отношения могут быть такими же
как в SQL: 1-1, 1-N, N-N.\par
\textbf{Внимание}: ID при вставке будут отличаться.\par
При отношении в виде вложенного документа, документ пользователя
будет выглядеть следующим образом:

\begin{image}
	\includegrph{img_5}
	\caption{Отношении в виде вложенного документа}
	\label{fig:relationship}
\end{image}

Документ можно найти следующим образом:

\begin{lstlisting}[language=bash]
> db.first.findOne({"name":"Tom Benzamin"},{"address":1})
\end{lstlisting}

Основным недостатком такого подхода является то, что большая
вложенность массивных документов негативно влияет на производительность
чтения/записи.

Основным недостатком такого подхода является то, что большая
вложенность массивных документов негативно влияет на производительность
чтения/записи.\par
Рассмотрим ссылочный подход. Теперь хранятся не сами адреса, а их id в
коллекциях.\par
После этого вставим документ пользователя, указав в массив
address\_ids те адреса, которые будут получены после вставки в коллекцию
address. Как видим, вставляются ObjectId вместо адресов.

\begin{image}
	\includegrph{img_6}
	\caption{Ссылочный подход}
	\label{fig:links}
\end{image}

Тогда запрос адресов, относящихся к данному пользователю, будет
состоять из 2 этапов: получения ObjectId адресов, запрос адресов.

\section{Ссылочные отношения}

Для реализации нормализованной структуры базы данных в MongoDB мы
используем концепцию ссылочных отношений, также называемых ручными
ссылками, в которой мы вручную сохраняем идентификатор ссылочного
документа внутри другого документа. Однако в тех случаях, когда документ
содержит ссылки из разных коллекций, мы можем использовать MongoDB
DBRefs.\par
В качестве примера, где мы будем использовать DBRef вместо ссылок
вручную, рассмотрим базу данных, в которой мы храним различные типы
адресов (домашний, офисный, почтовый) в разных коллекциях (address\_home,
address\_office, address\_mailing). Теперь, когда документ пользовательской
коллекции ссылается на адрес, он также должен указать, какую коллекцию
следует просматривать. В таких случаях, когда документ ссылается на
документы из многих коллекций, мы должны использовать DBRef.

В DBRefs есть три поля:

\begin{itemize}
	\item \texttt{\$ref} это поле указывает коллекцию ссылочного документа;
	\item \texttt{\$id} это поле указывает поле \_id ссылочного документа;
	\item \texttt{\$db} это необязательное поле и содержит имя базы данных,
	в которой находится ссылочный документ.
\end{itemize}

Получение адреса будет выглядеть следующим образом:

\begin{image}
	\includegrph{img_7}
	\caption{Ссылочные отношения}
	\label{fig:link:relationship}
\end{image}

\section{Атомарные операции}

MongoDB не поддерживает атомарные транзакции с несколькими
документами. Тем не менее, он обеспечивает атомарные операции над одним
документом. Таким образом, если документ имеет сто полей, оператор update
либо обновит все поля, либо ни одного, следовательно, сохраняя атомарность
на уровне документа.\par
Рекомендуемый подход к сохранению атомарности заключается в
хранении всей связанной информации, которая часто обновляется, вместе в
одном документе с использованием встроенных документов. Это позволит
убедиться, что все обновления для одного документа являются атомарными.\par
В этом документе мы включили информацию о клиенте, который
покупает продукт, в поле product\_bought\_by. Теперь, когда новый клиент
покупает продукт, мы сначала проверяем, доступен ли продукт, используя
поле product\_available. Если доступно, мы уменьшим значение поля
product\_available, а также вставим встроенный документ нового клиента в поле
product\_bought\_by. Мы будем использовать команду \texttt{findOneAndUpdate}
для этой функциональности,
потому что она ищет и обновляет документ одновременно.

\begin{image}
	\includegrph{img_8}
	\caption{Выполнение findOneAndUpdate}
	\label{fig:findoneandupdate}
\end{image}

Подход к встроенному документу и использованию запроса
findOneAndUpdate гарантирует, что информация о покупке продукта обновляется
только в том случае, если продукт доступен. И вся эта транзакция, находящаяся
в одном запросе, является атомарной.\par
А теперь рассмотрим сценарий, в котором мы могли бы отдельно хранить
информацию о доступности продукта и информацию о том, кто его купил.\par
В этом случае мы сначала проверим, доступен ли продукт, используя
первый запрос. Затем во втором запросе мы обновим информацию о
покупке. Однако, возможно, что между выполнением этих двух запросов какойто другой пользователь приобрел продукт, и он больше не доступен. Не зная
этого, наш второй запрос обновит информацию о покупке на основе результата
нашего первого запроса. Это сделает базу данных
противоречивой/неконсистентной, потому что мы продали продукт, который
недоступен.

\clearpage

\section*{\LARGE Вывод}
\addcontentsline{toc}{section}{Вывод}
В данной практической работе мы используя знания из
предыдущей практической работы выполнили команды вставки, агрегации
и работы с отношениями в MongoDB.
А также изучили репликацию реализованную в MongoDB.